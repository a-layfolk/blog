(window.webpackJsonp=window.webpackJsonp||[]).push([[123],{596:function(v,_,t){"use strict";t.r(_);var a=t(25),r=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"软件设计基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软件设计基础"}},[v._v("#")]),v._v(" 软件设计基础")]),v._v(" "),t("p",[t("code",[v._v("软件设计")]),v._v("的任务可以分为概要设计和详细设计两个子阶段。")]),v._v(" "),t("ul",[t("li",[v._v("概要设计\n"),t("ul",[t("li",[v._v("体系结构设计")]),v._v(" "),t("li",[v._v("界面设计")]),v._v(" "),t("li",[v._v("数据设计")])])]),v._v(" "),t("li",[v._v("详细设计，详细设计的主要任务就是完成过程设计")])]),v._v(" "),t("h2",{attrs:{id:"软件体系结构设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软件体系结构设计"}},[v._v("#")]),v._v(" 软件体系结构设计")]),v._v(" "),t("p",[v._v("集中常见的、被广泛使用的软件体系结构模型：")]),v._v(" "),t("ul",[t("li",[v._v("以数据为中心的数据仓库模型")]),v._v(" "),t("li",[v._v("客户端/服务器模式的分布式结构")]),v._v(" "),t("li",[v._v("层次模型")]),v._v(" "),t("li",[v._v("MVC 模型")])]),v._v(" "),t("h2",{attrs:{id:"模块化设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模块化设计"}},[v._v("#")]),v._v(" 模块化设计")]),v._v(" "),t("h3",{attrs:{id:"软件模块化与分解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软件模块化与分解"}},[v._v("#")]),v._v(" 软件模块化与分解")]),v._v(" "),t("p",[v._v("通常情况下，问题总的复杂度会随着模块分解而趋于减小，工作量也同时减少。但如果模块分解过程无限进行下去，不仅问题的复杂度不会减少，相反还会增加。")]),v._v(" "),t("h3",{attrs:{id:"抽象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#抽象"}},[v._v("#")]),v._v(" 抽象")]),v._v(" "),t("ul",[t("li",[v._v("实体抽象，称为数据抽象，对需求陈述中实体的归纳。")]),v._v(" "),t("li",[v._v("接口抽象。")]),v._v(" "),t("li",[v._v("设计模式抽象。")])]),v._v(" "),t("h3",{attrs:{id:"信息隐藏"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#信息隐藏"}},[v._v("#")]),v._v(" 信息隐藏")]),v._v(" "),t("p",[v._v("信息隐藏就是把数据结构和实现放在一起，对完提供相对完整、独立的功能。")]),v._v(" "),t("h3",{attrs:{id:"模块独立性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模块独立性"}},[v._v("#")]),v._v(" 模块独立性")]),v._v(" "),t("p",[v._v("模块独立性是指软件系统中划分的模块完成一个相对独立的功能，而与其他模块的关联尽量只发生在接口上。")]),v._v(" "),t("h4",{attrs:{id:"内聚性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内聚性"}},[v._v("#")]),v._v(" 内聚性")]),v._v(" "),t("p",[v._v("内聚性是指"),t("strong",[v._v("模块内数据与操作之间的紧密程度")]),v._v("。内聚性越强，模块内部元素间关系越紧密，模块独立性越强。")]),v._v(" "),t("p",[v._v("内聚性分为七类，由低到高：")]),v._v(" "),t("ul",[t("li",[v._v("偶然内聚。模块间没有必然联系。")]),v._v(" "),t("li",[v._v("逻辑内聚。由模块参数指定将要执行的功能。比如 C 语言的 printf() 函数和 “%d”，“%s” 的关系。")]),v._v(" "),t("li",[v._v("时间内聚：各个任务彼此并无联系，但由于需要在同一时间运行而聚集在一起。比如初始化操作，类的构造函数和析构函数。")]),v._v(" "),t("li",[v._v("过程内聚：模块内部必须按照过程描述，自上而下组织任务。比如文件的“打开/预读”要在同一时间完成，“关闭/保存”要在同一时间完成。")]),v._v(" "),t("li",[v._v("通信内聚：模块中各成分引用共同的数据。")]),v._v(" "),t("li",[v._v("顺序内聚：前一部分的输出是后一部分的输入。")]),v._v(" "),t("li",[v._v("共南通内聚：模块内部各部分共同完成一个具体功能。")])]),v._v(" "),t("h4",{attrs:{id:"耦合度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#耦合度"}},[v._v("#")]),v._v(" 耦合度")]),v._v(" "),t("p",[v._v("耦合度是指"),t("strong",[v._v("模块间的紧密程度")]),v._v("。耦合度越低，模块间的紧密程度越松散，模块独立性越强。")]),v._v(" "),t("p",[v._v("耦合度分为六类，由低到高：")]),v._v(" "),t("ul",[t("li",[v._v("非直接耦合：模块间没有直接的相互调用关系")]),v._v(" "),t("li",[v._v("数据耦合：模块相互调用时，模块间传递基本数据类型")]),v._v(" "),t("li",[v._v("特征耦合：模块相互调用时，模块间传递复合数据类型")]),v._v(" "),t("li",[v._v("控制耦合：模块间传递控制变量，逻辑内聚就是典型的通过控制耦合来执行的模块")]),v._v(" "),t("li",[v._v("公共耦合：多个模块访问全局变量、结构、文件等公共信息")]),v._v(" "),t("li",[v._v("内容耦合：一个模块直接访问另一个模块内部中的数据，比如友元函数。")])]),v._v(" "),t("p",[v._v("应该“尽量使用数据耦合，少用控制耦合，限制公共耦合范围，坚决避免使用内容耦合”。")]),v._v(" "),t("h2",{attrs:{id:"界面设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#界面设计"}},[v._v("#")]),v._v(" 界面设计")]),v._v(" "),t("p",[v._v("著名的界面设计黄金三原则：")]),v._v(" "),t("p",[v._v("（1）置用户于控制之下；（2）减少用户的记忆负担；（3）保持界面一致")]),v._v(" "),t("p",[v._v("界面设计时画的设计图就是“原型图”。")]),v._v(" "),t("h2",{attrs:{id:"软件设计评审"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软件设计评审"}},[v._v("#")]),v._v(" 软件设计评审")]),v._v(" "),t("p",[v._v("软件结构设计说明（Structure Design Description，SSD）描述计算机软件配置项的设计。")])])}),[],!1,null,null,null);_.default=r.exports}}]);
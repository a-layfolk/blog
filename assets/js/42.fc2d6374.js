(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{501:function(t,a,s){"use strict";s.r(a);var r=s(25),n=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"模块机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块机制"}},[t._v("#")]),t._v(" 模块机制")]),t._v(" "),s("p",[t._v("JavaScript 原本缺乏一项功能:模块。历经发展后，CommonJS 规范的提出是非常重要的。")]),t._v(" "),s("h2",{attrs:{id:"commonjs-模块规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#commonjs-模块规范"}},[t._v("#")]),t._v(" CommonJS 模块规范")]),t._v(" "),s("p",[t._v("CommonJS 对模块的定义非常简单，主要分为：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("模块引入")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" math "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"math"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])]),t._v(" "),s("li",[s("p",[t._v("模块定义")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// math.js")]),t._v("\nexports"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("add")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" sum "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      args "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" arguments"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      l "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" l"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        sum "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" sum"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" math "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"./math"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("math"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("exports 具体是什么可以看后面的模块编译。")]),t._v(" "),s("p",[t._v("理想情况下，只需要赋值给 exports，但是通常会得到一个失败的结果。")]),t._v(" "),s("p",[t._v("原因是，exports 是通过形参方式传入的，直接赋值形参会改变形参的引用，但并不能改变作用域外的值。")]),t._v(" "),s("p",[t._v("所以一般情况用 module.exports")])])]),t._v(" "),s("li",[s("p",[t._v("模块标识")]),t._v(" "),s("p",[t._v("模块标识就是传递给 require() 方法的参数，它必须是：")]),t._v(" "),s("ul",[s("li",[t._v("符合小驼峰命名的字符串")]),t._v(" "),s("li",[t._v("或者以 ./ ../ 开头的相对路径")]),t._v(" "),s("li",[t._v("或者绝对路径")])])])]),t._v(" "),s("h2",{attrs:{id:"node-的模块实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#node-的模块实现"}},[t._v("#")]),t._v(" Node 的模块实现")]),t._v(" "),s("p",[t._v("在 Node 中引入模块，需要经历 3 个步骤：")]),t._v(" "),s("ul",[s("li",[t._v("路径分析")]),t._v(" "),s("li",[t._v("文件定位")]),t._v(" "),s("li",[t._v("编译执行")])]),t._v(" "),s("p",[t._v("在 node 中，模块分为两类：")]),t._v(" "),s("ul",[s("li",[t._v("Node 提供的模块，称为核心模块")]),t._v(" "),s("li",[t._v("用户编写的模块，称为文件模块")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("ul",[s("li",[t._v("核心模块部分，在 Node 源代码编译过程中，编译进了二进制执行文件。在 Node 进程启动时，部分核心模块就直接加载到内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并在路径分析中有限判断，所以它的加载速度是最快的")]),t._v(" "),s("li",[t._v("文件模块则是在运行时"),s("strong",[t._v("动态加载")]),t._v("，需要完成的 3 个步骤，速度比核心模块慢")])])]),t._v(" "),s("h3",{attrs:{id:"优先从缓存加载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优先从缓存加载"}},[t._v("#")]),t._v(" 优先从缓存加载")]),t._v(" "),s("p",[t._v("Node 对引入过的模块都会进行缓存，以减少二次引入的开销。")]),t._v(" "),s("p",[t._v("不管是核心模块还是文件模块，require() 方法对相同的二次加载都一律采用缓存优先的方式，这是"),s("strong",[t._v("第一优先级")]),t._v("的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。")]),t._v(" "),s("h3",{attrs:{id:"路径分析和文件定位"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#路径分析和文件定位"}},[t._v("#")]),t._v(" 路径分析和文件定位")]),t._v(" "),s("p",[s("strong",[t._v("路径分析")]),t._v("：")]),t._v(" "),s("p",[t._v("模块标识符分为以下几类：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("核心模块，如 http， fs，path 等")]),t._v(" "),s("p",[t._v("优先级仅次于缓存加载")])]),t._v(" "),s("li",[s("p",[t._v(". 或 .. 开始的相对路径模块")]),t._v(" "),s("p",[t._v("当作文件模块，速度慢于核心模块")])]),t._v(" "),s("li",[s("p",[t._v("以 / 开始的绝对路径模块")]),t._v(" "),s("p",[t._v("当作文件模块，速度慢于核心模块")])]),t._v(" "),s("li",[s("p",[t._v("非路径形式的文件模块，如自定义的 content 模块")]),t._v(" "),s("p",[t._v("特殊的文件模块，可能是一个文件或者包的形式，这类模块查找最耗时")])])]),t._v(" "),s("p",[t._v("模块路径的生成规则是向上逐级递归，具体可以看书 17 页。")]),t._v(" "),s("p",[s("strong",[t._v("文件定位：")])]),t._v(" "),s("p",[t._v("CommonJS 模块允许标识符中不包含文件拓展名，这种情况下，Node 会按 .js、.node、.json 的次序依次尝试")]),t._v(" "),s("p",[t._v("由于在尝试过程中，fs 模块同步阻塞式的判断文件是否存在，所以有一个小技巧是：如果是 .node 和 .json 文件，带上扩展名会更快。")]),t._v(" "),s("p",[t._v("如果分析标识符时，得到的是一个目录，那么会经过以下步骤：")]),t._v(" "),s("ul",[s("li",[t._v("查找 package.json ，通过 JSON.parse() 解析对象，取出 main 属性的文件进行定位")]),t._v(" "),s("li",[t._v("如果没有 package.json 文件，默认会把 index 当作文件名")])]),t._v(" "),s("h3",{attrs:{id:"模块编译"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块编译"}},[t._v("#")]),t._v(" 模块编译")]),t._v(" "),s("p",[t._v("编译和执行是引入文件模块的最后一个阶段，定位到具体文件后，Node 会新建一个模块对象，然后根据路径载入并编译。")]),t._v(" "),s("ul",[s("li",[t._v(".js 文件，通过 fs 模块同步读取文件后编译")]),t._v(" "),s("li",[t._v(".node 文件，这是用 C/C++ 编译的拓展文件，通过 dlopen() 方法加载最后编译生成的文件。在 Node 架构下，dlopen 在 Windows 和 *nix 平台分别有不同的实现，通过 libuv 兼容层进行封装。")]),t._v(" "),s("li",[t._v(".json 文件，通过 fs 模块同步读取文件后，用 JSON.parse() 解析返回结果")]),t._v(" "),s("li",[t._v("其余拓展文件名，它们会被当作 .js 文件载入")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("每个模块文件均存在 require，exports、module 这 3 个变量。事实上，Node 对获取的 JavaScript 文件内容进行了头尾封装。在头部添加了：")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("exports"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" require"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" module"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" __filename"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" __dirname")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("；\n")])])]),s("p",[t._v("这就是这些变量并没有定义但是却存在的原因。在执行之后，模块的 exports 属性被返回给了调用方。exports 属性上的任何方法和属性都可以被外部调用到，但是模块中的其余变量或属性则不可直接被调用。")])]),t._v(" "),s("h2",{attrs:{id:"核心模块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#核心模块"}},[t._v("#")]),t._v(" 核心模块")]),t._v(" "),s("p",[t._v("核心模块其实分为 C/C++ 编写的和 JavaScript 编写的两部分。其中 C/C++ 文件存放在 Node 项目的 src 目录下，JavaScript 文件存放在 lib 目录下。")]),t._v(" "),s("h3",{attrs:{id:"javascript-核心模块的编译过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript-核心模块的编译过程"}},[t._v("#")]),t._v(" JavaScript 核心模块的编译过程")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("转存为 C/C++ 代码")]),t._v(" "),s("p",[t._v("Node 采用了 V8 附带的 js2c.py 工具，将所有内置的 JavaScript 代码转换成 C++ 里的数组，生成 node_natives.h 头文件。")]),t._v(" "),s("p",[t._v("在这个过程中，JavaScript 代码以字符串的形式存储在 node 命名空间中，是不可以直接执行的。启动 Node 进程时，JavaScript 代码直接加载进内存中。")])]),t._v(" "),s("li",[s("p",[t._v("编译 JavaScript 核心模块")]),t._v(" "),s("p",[t._v("lib 目录下的所有模块文件也没有定义 require、module、exports 这些变量。在引入 JavaScript 核心模块的过程中，也经历了头尾包装的的过程，然后才执行和导出了 exports 对象。")]),t._v(" "),s("p",[t._v("JavaScript 核心模块的文件中，编译成功的模块缓存到 "),s("code",[t._v("NativeModule._cache")]),t._v(" 对象上，文件模块则缓存到 "),s("code",[t._v("Module._cache")]),t._v(" 对象上。")])])]),t._v(" "),s("h3",{attrs:{id:"c-c-核心模块的编译过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#c-c-核心模块的编译过程"}},[t._v("#")]),t._v(" C/C++ 核心模块的编译过程")]),t._v(" "),s("p",[t._v("将那些由纯 C/C++ 编写的部分统一称为内建模块，因为它们通常不会被用户直接调用。Node 的 buffer、crypto、evals、fs、os 等模块都是部分通过 C/C++ 编写的。")]),t._v(" "),s("p",[s("strong",[t._v("1. 内建模块的组织形式")])]),t._v(" "),s("p",[t._v("每一个内建模块在定义之后，都通过 "),s("code",[t._v("NODE_MODULE")]),t._v(" 宏将模块定义到 node 命名空间中。")]),t._v(" "),s("p",[s("strong",[t._v("2. 内建模块的导出")])]),t._v(" "),s("p",[t._v("在 Node 的所有模块类型中，存在着依赖关系。即文件模块可能会依赖核心模块，核心模块可以会依赖内建模块。")]),t._v(" "),s("h3",{attrs:{id:"核心模块的引入流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#核心模块的引入流程"}},[t._v("#")]),t._v(" 核心模块的引入流程")]),t._v(" "),s("p",[t._v("为了符合 CommonJS 模块规范，从 JavaScript 到 C/C++ 的过程是相当复杂的。它要经历 C/C++ 层面的内建模块定义，（JavaScript）核心模块的定义和引入以及（JavaScript）文件模块层面的引入。")]),t._v(" "),s("h3",{attrs:{id:"编写核心模块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编写核心模块"}},[t._v("#")]),t._v(" 编写核心模块")]),t._v(" "),s("p",[t._v("这个具体可以看书籍 26 页。")]),t._v(" "),s("h3",{attrs:{id:"c-c-扩展模块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#c-c-扩展模块"}},[t._v("#")]),t._v(" C/C++ 扩展模块")]),t._v(" "),s("p",[t._v("JavaScript 的一个典型弱点就是位运算。JavaScripr 中只有 double 型的数据类型，在进行位运算的过程中，需要将 double 型转换为 int 型，然后再进行。所以，在 JavaScript 层面上做位运算的效率不高。")]),t._v(" "),s("p",[t._v("在应用中，会频繁出现位运算的需求，包括转码、编码等过程，这时编写 C/C++ 拓展模块来提升性能。")]),t._v(" "),s("h3",{attrs:{id:"c-c-扩展模块的编译"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#c-c-扩展模块的编译"}},[t._v("#")]),t._v(" C/C++ 扩展模块的编译")]),t._v(" "),s("p",[t._v("GYP 工具。这里没看懂，具体可以看书 31 页")]),t._v(" "),s("h2",{attrs:{id:"模块调用栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块调用栈"}},[t._v("#")]),t._v(" 模块调用栈")]),t._v(" "),s("p",[t._v("C/C++ 内建模块属于最底层的模块，它属于核心模块，主要提供 API 的 JavaScript 核心模块和第三方 JavaScript 文件模块。")]),t._v(" "),s("p",[t._v("JavaScript 核心模块主要扮演的职责有两类：")]),t._v(" "),s("ul",[s("li",[t._v("一类是作为 C/C++ 内建模块的封装层和桥接层，供文件模块调用；")]),t._v(" "),s("li",[t._v("一类是存粹的功能模块，它不需要跟底层打交道，但是又十分重要")])]),t._v(" "),s("h2",{attrs:{id:"包与-npm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#包与-npm"}},[t._v("#")]),t._v(" 包与 NPM")]),t._v(" "),s("p",[t._v("CommonJS 的包规范的定义由两个部分组成")]),t._v(" "),s("ul",[s("li",[t._v("包结构，用于组织包中的各种文件")]),t._v(" "),s("li",[t._v("包描述文件，用于描述包的相关信息")])]),t._v(" "),s("h3",{attrs:{id:"包结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#包结构"}},[t._v("#")]),t._v(" 包结构")]),t._v(" "),s("p",[t._v("完全符合 CommonJS 规范的包目录应该包含如下这些文件：")]),t._v(" "),s("ul",[s("li",[t._v("package.json：包描述文件")]),t._v(" "),s("li",[t._v("bin：用于存放可执行二进制文件的目录")]),t._v(" "),s("li",[t._v("lib：用于存放 JavaScript 代码的目录")]),t._v(" "),s("li",[t._v("doc：用于存放文档的目录")]),t._v(" "),s("li",[t._v("test：用于存放单元测试用例的代码")])]),t._v(" "),s("h3",{attrs:{id:"包描述文件与-npm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#包描述文件与-npm"}},[t._v("#")]),t._v(" 包描述文件与 NPM")]),t._v(" "),s("p",[t._v("如下必须字段：")]),t._v(" "),s("ul",[s("li",[t._v("name：包名")]),t._v(" "),s("li",[t._v("description：包简介")]),t._v(" "),s("li",[t._v("version：版本号")]),t._v(" "),s("li",[t._v("keywords：关键字数组")]),t._v(" "),s("li",[t._v("maintainers：包维护列表，每个维护者由 name、email 和 web 这 3 个属性组成")])]),t._v(" "),s("p",[t._v("具体的可以看 36 页。")]),t._v(" "),s("h3",{attrs:{id:"npm-常用功能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#npm-常用功能"}},[t._v("#")]),t._v(" NPM 常用功能")]),t._v(" "),s("p",[s("strong",[t._v("1. 查看帮助")])]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("npm")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 直接执行 npm 查看到帮助引导说明")]),t._v("\n")])])]),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("npm")]),t._v(" -v "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 查看当前 npm 的版本")]),t._v("\n")])])]),s("p",[s("strong",[t._v("2. 安装依赖包")])]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("npm")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("模块名"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" -g "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 全局模式安装")]),t._v("\n")])])]),s("p",[t._v("对于一些没有发布到 NPM 的包，或是因为网络原因导致无法直接安装的包，可以通过将包下载到本地，然后以本地安装。本地安装只需位 NPM 指明 package.json 文件所在的位置即可。")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("npm")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("tarball file"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),s("p",[t._v("从非官方源安装，可以通过镜像源安装。在执行命令时，添加 --registry=http://registry.url 即可，示例如下：")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("npm")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" underscore --registry"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("http://registry.url\n")])])]),s("p",[t._v("如果使用过程中几乎都采用镜像源安装，可以执行以下命令指定默认源：")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("npm")]),t._v(" config "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("set")]),t._v(" registry http://registry.url\n")])])]),s("p",[s("strong",[t._v("3. NPM 钩子命令")])]),t._v(" "),s("p",[t._v("package.json 中，scripts 字段的提出就是让包在安装或者卸载等过程中提供钩子机制，示例如下：")]),t._v(" "),s("div",{staticClass:"language-json extra-class"},[s("pre",{pre:!0,attrs:{class:"language-json"}},[s("code",[s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"scripts"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"preinstall"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"preinstall.js"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"install"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"install.js"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"uninstall"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"uninstall.js"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"test"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"test.js"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("比如在以上字段中执行 "),s("code",[t._v("npm install <package>")]),t._v(" 时，preinstall 指向的脚本将会被加载执行，然后 install 指向的脚本将会执行。在执行 "),s("code",[t._v("npm uninstall <package>")]),t._v(" 时，uninstall 指向的脚本也许会做一些清理工作等。")]),t._v(" "),s("p",[s("strong",[t._v("4. 发布包")])]),t._v(" "),s("ul",[s("li",[t._v("编写模块")]),t._v(" "),s("li",[t._v("初始化包描述文件")]),t._v(" "),s("li",[t._v("注册包仓库账号")]),t._v(" "),s("li",[t._v("上传包")]),t._v(" "),s("li",[t._v("安装包")]),t._v(" "),s("li",[t._v("管理包权限")])]),t._v(" "),s("p",[s("strong",[t._v("5. 分析包")])]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("npm")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ls")]),t._v("\n")])])]),s("h3",{attrs:{id:"局域-npm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#局域-npm"}},[t._v("#")]),t._v(" 局域 NPM")]),t._v(" "),s("p",[t._v("为了同时能够享受到 NPM 上众多的包，同时对自己的包进行保密和限制，现有的解决方案就是企业搭建自己的 NPM 仓库。详情看书附录 D")]),t._v(" "),s("h3",{attrs:{id:"npm-潜在问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#npm-潜在问题"}},[t._v("#")]),t._v(" NPM 潜在问题")]),t._v(" "),s("p",[t._v("潜在的问题在于：")]),t._v(" "),s("ul",[s("li",[t._v("在 NPM 平台上，每个人都可以分享包到平台上，鉴于开发人员水平不一，上面的包的质量也良莠不齐")]),t._v(" "),s("li",[t._v("Node 代码可以运行在服务器端，需要考虑安装问题")])]),t._v(" "),s("p",[t._v("看包的质量")]),t._v(" "),s("ul",[s("li",[t._v("第一，NPM 模块首页上的依赖榜")]),t._v(" "),s("li",[t._v("第二，GitHub")]),t._v(" "),s("li",[t._v("第三，包中的测试用例和文档")])]),t._v(" "),s("h3",{attrs:{id:"前后端共用模块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前后端共用模块"}},[t._v("#")]),t._v(" 前后端共用模块")]),t._v(" "),s("p",[t._v("浏览器端的 JavaScript 需要经历从一个服务器端分发到多个客户端执行, 而服务器端 JavaScript 则是相同的代码需要多次执行。")]),t._v(" "),s("ul",[s("li",[t._v("浏览器通过网络加载代码，它的瓶颈在于带宽，")]),t._v(" "),s("li",[t._v("服务端从磁盘中加载，它的瓶颈在于 CPU 和内存等资源")])]),t._v(" "),s("p",[t._v("鉴于网络的原因，CommonJS 为后端 JavaScript 制定的规范并不完全适合前端的应用场景。经过一段争执之后，AMD 规范最终在前端应用场景中胜出。")])])}),[],!1,null,null,null);a.default=n.exports}}]);
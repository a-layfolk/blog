(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{582:function(v,_,t){"use strict";t.r(_);var r=t(25),a=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"数据链路层"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据链路层"}},[v._v("#")]),v._v(" 数据链路层")]),v._v(" "),t("h2",{attrs:{id:"数据链路层的设计问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据链路层的设计问题"}},[v._v("#")]),v._v(" 数据链路层的设计问题")]),v._v(" "),t("p",[v._v("数据链路层要完成一些功能：")]),v._v(" "),t("ul",[t("li",[v._v("向网络层提供一个定义良好的服务接口")]),v._v(" "),t("li",[v._v("处理传输错误")]),v._v(" "),t("li",[v._v("调节数据流，确保慢速的接收方不会被快速的发送方淹没")])]),v._v(" "),t("h3",{attrs:{id:"提供给网络层的服务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#提供给网络层的服务"}},[v._v("#")]),v._v(" 提供给网络层的服务")]),v._v(" "),t("p",[v._v("数据链路层通常会提供以下 3 种可能的服务：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("无确认的无连接服务")]),v._v(" "),t("p",[v._v("适合两种场合：")]),v._v(" "),t("ul",[t("li",[v._v("错误率很低")]),v._v(" "),t("li",[v._v("实时通信、比如语音传输")])])]),v._v(" "),t("li",[t("p",[v._v("有确认的无连接服务")]),v._v(" "),t("p",[v._v("适合用不确定的信道，比如无线系统 WIFI")])]),v._v(" "),t("li",[t("p",[v._v("有确认的有连接服务")]),v._v(" "),t("p",[v._v("保证每个帧只被接收一次，并且所有的帧都将按正确的顺序接收。")]),v._v(" "),t("p",[v._v("适用于长距离且不可靠的链路，比如卫星信道或者长途电话电路。")])])]),v._v(" "),t("h3",{attrs:{id:"成帧"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#成帧"}},[v._v("#")]),v._v(" 成帧")]),v._v(" "),t("p",[v._v("数据在网络上是以很小的称为帧（Frame）的单位传输的。")]),v._v(" "),t("p",[v._v("数据链路层会把比特流拆分为多个离散的帧，并为每个帧提供一个称为校验和的短令牌，将校验和放在帧种一起传输。")]),v._v(" "),t("p",[v._v("当帧到达目标机器时，会重新计算校验和，如果新算出来的校验和与原校验和不同，则说明传输过程中出现了错误。")]),v._v(" "),t("p",[t("strong",[v._v("拆分比特流")])]),v._v(" "),t("p",[v._v("拆分比特流有四种方法")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("字节计数法")]),v._v(" "),t("p",[v._v("利用头部的一个字段来标识该帧中的字符数")]),v._v(" "),t("p",[v._v("缺陷：")]),v._v(" "),t("ul",[t("li",[v._v("可能因为一个传输错误而被弄混")])])]),v._v(" "),t("li",[t("p",[v._v("字节填充的标志字节法")]),v._v(" "),t("p",[v._v("每个帧用一个特殊字节作为开始和结束。特殊字节称为"),t("strong",[v._v("标志字节")]),v._v("。")]),v._v(" "),t("p",[v._v("标志字节如果出现在数据中，需要在标志字节前面添加"),t("strong",[v._v("转义字节")]),v._v("（ESC），接收时需要删除转义字节，称为"),t("strong",[v._v("字节填充")]),v._v("。")]),v._v(" "),t("p",[v._v("如果转义字节出现在数据中，那么同样要在转义字节前面增加转义字节。")]),v._v(" "),t("p",[v._v("类似的协议有 PPP 协议。")]),v._v(" "),t("p",[v._v("缺点：")]),v._v(" "),t("ul",[t("li",[v._v("一帧的长度要取决于所携带的数据内容")]),v._v(" "),t("li",[v._v("有转义字节则需要长度会增加")])])]),v._v(" "),t("li",[t("p",[v._v("比特填充的标志比特法")]),v._v(" "),t("p",[v._v("每个帧的开始和结束由一个特殊的比特模式，0111 1110 或十六进制的 0x7E 标记。这种模式是一个标志字节。")]),v._v(" "),t("p",[v._v("每当发送方数据的数据链路层，在数据中发现连续 5 个 1，它们便自动在输出的字节流中填入一个比特 0。")]),v._v(" "),t("p",[v._v("接收方看到 5 个连续的比特 1，后面紧跟着一个 0 ，它就自动剔除 0")]),v._v(" "),t("p",[v._v("缺点：")]),v._v(" "),t("ul",[t("li",[v._v("一帧的长度要取决于所携带的数据内容")]),v._v(" "),t("li",[v._v("有转义字节则需要长度会增加")])])]),v._v(" "),t("li",[t("p",[v._v("物理层编码违禁法")]),v._v(" "),t("p",[v._v("比特编码成信号通常包括一些冗余比特。我们可以利用这些保留的信号来只是帧的开始和结束")])])]),v._v(" "),t("h3",{attrs:{id:"差错控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#差错控制"}},[v._v("#")]),v._v(" 差错控制")]),v._v(" "),t("p",[v._v("如何确认所有的帧最终都传递给目标机器的网络层，并且保持正确的顺序？")]),v._v(" "),t("ul",[t("li",[v._v("常用方法是向发送方提供一些反馈信息")])]),v._v(" "),t("p",[v._v("如果数据帧完全丢失了，发送方一直发送怎么办？")]),v._v(" "),t("ul",[t("li",[v._v("在数据链路层引入计时器，超时未接到反馈，则说明帧已经丢失")])]),v._v(" "),t("p",[v._v("帧丢失后要重发，如果有的帧被发送了多次怎么办？")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("一般有必要给发送出去的帧分配序号，这样接收方可以根据帧的序号有效区分原始帧和重传帧")]),v._v(" "),t("h3",{attrs:{id:"流量控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#流量控制"}},[v._v("#")]),v._v(" 流量控制")])])]),v._v(" "),t("p",[v._v("如果发送方发送帧的速度超过了接收方能够接受这些帧的速度，发送方应该如何处理？")]),v._v(" "),t("ul",[t("li",[v._v("第一种方法是，"),t("strong",[v._v("基于反馈的流量控制")]),v._v("，（feedback-based flow control）接收方给发送方返回信息，允许它发送更多的数据，或者至少高速发送方自己情况怎么样。")]),v._v(" "),t("li",[v._v("第二种方法是，"),t("strong",[v._v("基于速率的流量控制")]),v._v("，（rate-based flow control），使用这种方法的协议有一种内置机制，它能限制发送方传输数据的速率，无需接收方的反馈信息。")])]),v._v(" "),t("h2",{attrs:{id:"差错检测和纠正"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#差错检测和纠正"}},[v._v("#")]),v._v(" 差错检测和纠正")]),v._v(" "),t("p",[v._v("传输错误非常普遍，我们应该如何处理传输错误呢？")]),v._v(" "),t("ul",[t("li",[v._v("纠错码（error-correcting code），也常称为"),t("strong",[v._v("前向纠错")]),v._v("（FEC，Forward Error Correction）")]),v._v(" "),t("li",[v._v("检错码（error-detecting code）")])]),v._v(" "),t("p",[v._v("无论是纠错码还是检错码都无法处理所有可能的传输错误，因为提供保护措施的冗余可能像数据比特一样出现错误。（可危及它们的保护作用）。")]),v._v(" "),t("p",[v._v("记住两点：")]),v._v(" "),t("ul",[t("li",[v._v("纠错和检错的问题出现在任何层")]),v._v(" "),t("li",[v._v("差错编码是应用的数学，除非特别熟悉伽罗瓦领域或稀疏矩阵的性质，否则不要自己设计编码")])]),v._v(" "),t("h3",{attrs:{id:"纠错码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#纠错码"}},[v._v("#")]),v._v(" 纠错码")]),v._v(" "),t("p",[v._v("块码、码字（n 位） = 校验位（r 位）+ 数据位（m 位）")]),v._v(" "),t("p",[t("strong",[v._v("码率")]),v._v("：不包含冗余部分所占的比例—— n/m")]),v._v(" "),t("p",[v._v("考察四种纠错编码：")]),v._v(" "),t("ul",[t("li",[v._v("海明码")]),v._v(" "),t("li",[v._v("二进制卷积码（未了解）")]),v._v(" "),t("li",[v._v("里得所罗门码（未了解）")]),v._v(" "),t("li",[v._v("低密度奇偶校验码（未了解）")])])])}),[],!1,null,null,null);_.default=a.exports}}]);
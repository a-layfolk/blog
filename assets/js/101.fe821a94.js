(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{571:function(v,_,t){"use strict";t.r(_);var a=t(25),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"有限自动机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有限自动机"}},[v._v("#")]),v._v(" 有限自动机")]),v._v(" "),t("p",[v._v("有限自动机（Finite Automaton，FA），它是与 4 类文法中最基本、最重要的 3 型文法等价的，即他能识别正则文法所定义的语言。")]),v._v(" "),t("h2",{attrs:{id:"确定的有限自动机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#确定的有限自动机"}},[v._v("#")]),v._v(" 确定的有限自动机")]),v._v(" "),t("p",[v._v("确定的有限自动机（Deterministic Finite Automaton，DFA）是一个五元组，是一个从 Q × Σ 到 Q 的映射。")]),v._v(" "),t("p",[v._v("DFA 可以用状态表或者状态图表示。")]),v._v(" "),t("ul",[t("li",[v._v("状态表：第一列的第一行为开始状态，上角标带 “*” 的是 Z 中的状态。")]),v._v(" "),t("li",[v._v("状态图")])]),v._v(" "),t("p",[v._v("如何"),t("code",[v._v("接受")]),v._v("或"),t("code",[v._v("识别")]),v._v("字符串：定义比较复杂，可以看书 32 页。下面从状态图触发可以更形象地进行描述。即：")]),v._v(" "),t("p",[v._v("若存在一条从初始节点到某一终态结点的路径，且在这条路径上所有弧的标记连接成的字符串等于 w，则称 w 被确定的有限自动机 M 所识别。特例的是，若 M 的初始节点同时又是终态节点，则空串 ε 被 M 所识别。")]),v._v(" "),t("p",[v._v("DFA M 识别的字符串全体称为 M 识别的语言，记为 L(M)。")]),v._v(" "),t("p",[v._v("识别过程有两种表示方法：")]),v._v(" "),t("ul",[t("li",[v._v("用转换函数的形式来表示，具体看书 32 页")]),v._v(" "),t("li",[v._v("从状态转换图进行描述：有一条从初态节点到一终态节点的路径")])]),v._v(" "),t("h2",{attrs:{id:"非确定的有限自动机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#非确定的有限自动机"}},[v._v("#")]),v._v(" 非确定的有限自动机")]),v._v(" "),t("p",[v._v("非确定的有限自动机（Nondeterministic Finite Automaton，MFA）是一个五元组。相比有限自动机，它在某状态下输入一字符的转换状态不是唯一的，可以转换为多个状态，并且允许不扫描字符串就可转换状态。")]),v._v(" "),t("p",[v._v("NFA 与 DFA 的重要区别：")]),v._v(" "),t("ul",[t("li",[v._v("NFA 的状态转换函数值是一个状态子集，反映在状态转换图上即是从一状态结点触发可以有不只一条同一标记的弧。")]),v._v(" "),t("li",[v._v("非确定的有限自动机可以带 ε 转换（不处理任何符号就进行状态转换）")])]),v._v(" "),t("p",[v._v("识别方法可以使用状态转换图，其中 "),t("code",[v._v("f({q0, q1}, 1) = {f(q0, q), f(q1, 1)}")]),v._v(" 可以帮助我们快速转换。")]),v._v(" "),t("h2",{attrs:{id:"dfa-与-nfa-的等价"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dfa-与-nfa-的等价"}},[v._v("#")]),v._v(" DFA 与 NFA 的等价")]),v._v(" "),t("p",[v._v("NFA 中，状态集 "),t("code",[v._v("ε-closure(I)")]),v._v(" 称为状态集 I 的闭包，代表 I 自身以及经过若干条 ε 弧形成的状态集。")]),v._v(" "),t("p",[v._v("NFA 中，In 是所有从 I 的 ε 闭包出发，经过一条 a 弧而到达的状态集的 ε 闭包。")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),t("p",[v._v("In 的状态集 ε 闭包，也就是得到状态集之后，还要对状态集求闭包")])]),v._v(" "),t("p",[t("strong",[v._v("定理：对任何一个非确定的优先级 M，都存在一个确定的有限自动机 M'，使 L(M') = L(M)。")])]),v._v(" "),t("p",[v._v("非确定的有限自动机的确定化算法——"),t("strong",[v._v("子集法")]),v._v("：详见 37 页例 2-20")]),v._v(" "),t("h2",{attrs:{id:"确定的有限自动机的化简"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#确定的有限自动机的化简"}},[v._v("#")]),v._v(" 确定的有限自动机的化简")]),v._v(" "),t("p",[v._v("如同文法描述语言一样，对一种语言，它可以用许多文法来描述。在利用有限自动机识别语言时，同样可以有无限多个有限自动机来识别同一种语言。其中有一个最小的 DFM。")]),v._v(" "),t("ul",[t("li",[v._v("定义：DFM M 中，如果对任意输入字符串 w1，从 q1，q2 状态触发，总是同时到达接受状态或拒绝状态之中，则称 q1，q2 是等价的")]),v._v(" "),t("li",[v._v("定义：如果从 DFM M 的初态开始，识别任何输入序列都不能到达的那些状态称为无关状态。")]),v._v(" "),t("li",[v._v("定义：如果有 DFM M，既没有无关状态，又没有彼此等价的状态，则称该 DEM M 是规约的（即最小的 DFM M）")])]),v._v(" "),t("p",[v._v("构造最小的 DFM 的步骤：1. 消除无关状态；2. 消除等价状态——"),t("strong",[v._v("划分法")]),v._v("。具体看书 39 页例 2-21 和 40 页 2-22。")])])}),[],!1,null,null,null);_.default=s.exports}}]);
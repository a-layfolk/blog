(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{468:function(_,v,t){_.exports=t.p+"assets/img/scanner.91bfd184.jpg"},469:function(_,v,t){_.exports=t.p+"assets/img/Paired_and_semi_complementary_buffer_structure.d0890a7a.jpg"},574:function(_,v,t){"use strict";t.r(v);var a=t(25),s=Object(a.a)({},(function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h1",{attrs:{id:"词法分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#词法分析"}},[_._v("#")]),_._v(" 词法分析")]),_._v(" "),a("h2",{attrs:{id:"词法分析与词法分析程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#词法分析与词法分析程序"}},[_._v("#")]),_._v(" 词法分析与词法分析程序")]),_._v(" "),a("p",[_._v("词法分析（lexical analysis）完成编译程序第一阶段的工作。")]),_._v(" "),a("p",[a("img",{attrs:{src:t(468),alt:""}})]),_._v(" "),a("p",[_._v("词法分析器识别出具有独立意义的最小语法单位——单词，将单词变换成带有单词性质且定长的属性字。")]),_._v(" "),a("h2",{attrs:{id:"词法程序设计与实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#词法程序设计与实现"}},[_._v("#")]),_._v(" 词法程序设计与实现")]),_._v(" "),a("h3",{attrs:{id:"词法分析程序的基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#词法分析程序的基本概念"}},[_._v("#")]),_._v(" 词法分析程序的基本概念")]),_._v(" "),a("p",[a("strong",[_._v("1. 单词")])]),_._v(" "),a("p",[_._v("单词就是语言中具有独立意义的最小语法单位。到底那些语法符号是语言中具有独立意义的最小语法单位，与具体的词法有关。一般常用的程序设计语言的单词可分为这样几类：")]),_._v(" "),a("ul",[a("li",[a("p",[_._v("关键字（保留字、基本字）")]),_._v(" "),a("p",[_._v("比如 C 语言中的 int、for、break")])]),_._v(" "),a("li",[a("p",[_._v("常数")]),_._v(" "),a("p",[_._v("比如：整型常数、布尔常数、字符及字符串常数等")])]),_._v(" "),a("li",[a("p",[_._v("标识符")]),_._v(" "),a("p",[_._v("用来表示各类名称的标识：比如，变量名、数组名、结构名、函数名等")])]),_._v(" "),a("li",[a("p",[_._v("运算符")]),_._v(" "),a("p",[_._v("比如算术运算 +、-、*、/ 等，逻辑运算 &&、|、！等")])]),_._v(" "),a("li",[a("p",[_._v("界限符")]),_._v(" "),a("p",[_._v("比如逗号，分号，括号，单引号和双引号")])])]),_._v(" "),a("p",[a("strong",[_._v("2. 属性字")])]),_._v(" "),a("p",[_._v("属性字（Token）是扫描器对源程序中各单词处理后的输出形式，也是单词在编译程序处理过程的一种内部标识。一般设计成如下二元组的结构形式："),a("code",[_._v("(单词属性, 单词值)")])]),_._v(" "),a("p",[_._v("对于一个语言，如何对其中的单词进行分类，分成几类，怎样编码，单词属性部分能包含多少信息等，并没有一个原则性的规定，要视具体情况而定，主要取决于处理上的方便。")]),_._v(" "),a("h3",{attrs:{id:"源程序的输入与预处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#源程序的输入与预处理"}},[_._v("#")]),_._v(" 源程序的输入与预处理")]),_._v(" "),a("p",[_._v("词法分析器工作的第一步是接受输入源程序，通常是把输入的源程序引导至一个输入缓冲区，并对输入缓冲区进行预处理，然后才交付扫描器进行处理。")]),_._v(" "),a("p",[a("strong",[_._v("1. 输入到缓冲区")])]),_._v(" "),a("p",[_._v("在词法分析过程中，编译程序借助操作系统从外部存储介质（如硬盘或软盘等）一次读取源文件中的内容。为了提高读取磁盘的效率，方便词法分析器的处理工作，一般采用"),a("strong",[_._v("缓冲输入方案")]),_._v("。及在内存中开辟一个大小适当的输入缓冲区，将源程序从磁盘上分批读入缓冲器，再由扫描器从缓冲区中扫描和处理。")]),_._v(" "),a("p",[_._v("例子：成对且对半互补的输入缓冲区模式。")]),_._v(" "),a("p",[a("img",{attrs:{src:t(469),alt:""}})]),_._v(" "),a("ul",[a("li",[a("p",[_._v("指针 B 称为起始位置指针，指向当前扫描的第一个字符")])]),_._v(" "),a("li",[a("p",[_._v("指针 F 称为向前搜索指针，用来寻找单词的终点")])]),_._v(" "),a("li",[a("p",[_._v("扫描器每次把长度为 n 的源程序输入到缓冲区的一个半区，如果指针 F 从单词七点出发搜索到半区的边缘（每个半区边缘设专门标记标识）仍未到达单词的重点，就把源程序后续的 n 个字符输入到另一个半区，这样两个半区交替使用达到互补。")]),_._v(" "),a("p",[_._v("（之所以这样设计，是因为无论缓冲区设得多大，都不能保证单词符号不被它的边界截断）")])])]),_._v(" "),a("p",[a("strong",[_._v("2. 源程序的预处理")])]),_._v(" "),a("p",[_._v("实际的词法分析程序往往带有预处理子程序，因此 它真正接收到的输入是经过预处理的源程序串。")]),_._v(" "),a("p",[_._v("预处理子程序一般完成的主要功能是：")]),_._v(" "),a("ul",[a("li",[_._v("滤掉源程序中的注释")]),_._v(" "),a("li",[_._v("剔除源程序中无用字符")]),_._v(" "),a("li",[_._v("进行宏替换")]),_._v(" "),a("li",[_._v("发现文件包含的嵌入和条件编译的嵌入等")])]),_._v(" "),a("h3",{attrs:{id:"单词的识别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单词的识别"}},[_._v("#")]),_._v(" 单词的识别")]),_._v(" "),a("p",[_._v("一般程序语言中的单词，在对源程序依次扫描中即可立即确认。")]),_._v(" "),a("p",[_._v("对某些语言，F 指针搜索到一个单词重点就能确认这个单词；对另外的一些语言，需要超前搜索才能够识别。")]),_._v(" "),a("h3",{attrs:{id:"词法分析程序与语法分析程序的接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#词法分析程序与语法分析程序的接口"}},[_._v("#")]),_._v(" 词法分析程序与语法分析程序的接口")]),_._v(" "),a("p",[_._v("可以把词法分析程序作为独立的一遍，把字符串转换成单词序列，输出到一个中间文件，该文件可以作为语法分析的输入。")]),_._v(" "),a("p",[_._v("更一般的情况是将词法分析阶段设计成一个子程序，每当语法分析需要读取单词时，就调用该子程序。这种方案词法分析和语法分析处于同一遍。")]),_._v(" "),a("h3",{attrs:{id:"词法分析器的设计与实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#词法分析器的设计与实现"}},[_._v("#")]),_._v(" 词法分析器的设计与实现")]),_._v(" "),a("p",[a("strong",[_._v("1. 作为词法分析器的状态转换图")])]),_._v(" "),a("p",[_._v("步骤如下：")]),_._v(" "),a("ul",[a("li",[_._v("对程序语言的单词按类构造出相应的状态转换图")]),_._v(" "),a("li",[_._v("对各类状态转换图合并，构成一个能识别语言所有单词的状态转换图。具体合并方法为：\n"),a("ul",[a("li",[_._v("将各类单词的状态转换图的初始状态合并为一个唯一的初态")]),_._v(" "),a("li",[_._v("化简并调整冲突和状态编号")])])])]),_._v(" "),a("p",[_._v("具体请看书 63 页，例 3-2、例 3-3。")]),_._v(" "),a("p",[a("strong",[_._v("2. 状态转换图的实现")])]),_._v(" "),a("p",[_._v("如何将状态转换图变为一个可行的词法分析器呢？最常用的状态转换图的实现方法称之为"),a("strong",[_._v("程序中心法")]),_._v("，即把状态转换图看成一个流程图，从状态转换图的初态开始，对它的每一个状态结点编一段相应的程序。具体请看书 65 页、66 页。")]),_._v(" "),a("p",[_._v("状态转换图实现的另一种方法是数据中心法，即将状态转换图看成一种数据结构（如状态矩阵表）。实际的状态矩阵表一般是一个稀疏矩阵，因此可以采用"),a("strong",[_._v("压缩的二级目录表")]),_._v("的数据结构。")]),_._v(" "),a("p",[_._v("所谓二级目录表：分为主表和分表")]),_._v(" "),a("ul",[a("li",[_._v("主表：状态和分表地址两个数据项。若状态为终态（即单词接收态），则分表地址是处理相应单词的子函数入口。")]),_._v(" "),a("li",[_._v("分表：当前输入字符及转换状态两个数据项。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);
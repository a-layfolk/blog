(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{446:function(_,v,t){_.exports=t.p+"assets/img/virtual_address_to_physical_address.437ba798.jpg"},447:function(_,v,t){_.exports=t.p+"assets/img/index_of_page_table_of_contents_and_page_table.08d41728.jpg"},448:function(_,v,t){_.exports=t.p+"assets/img/three_components_of_linear_address.e406f5f9.jpg"},449:function(_,v,t){_.exports=t.p+"assets/img/format_of_page_table_entries.45ffe055.jpg"},562:function(_,v,t){"use strict";t.r(v);var s=t(25),a=Object(s.a)({},(function(){var _=this,v=_.$createElement,s=_._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[s("h1",{attrs:{id:"微处理器管理模式-中"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#微处理器管理模式-中"}},[_._v("#")]),_._v(" 微处理器管理模式（中）")]),_._v(" "),s("h2",{attrs:{id:"内存管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[_._v("#")]),_._v(" 内存管理")]),_._v(" "),s("p",[_._v("CPU 通过对内部存储器的管理实现任务切换和资源调配。早期的 16 位 CPU 通过分段方法实现对内存的管理，32 位 CPU 采用分段和分页结合的方式实现对内存的管理。")]),_._v(" "),s("h3",{attrs:{id:"实模式下分段管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实模式下分段管理"}},[_._v("#")]),_._v(" 实模式下分段管理")]),_._v(" "),s("p",[s("strong",[_._v("分段管理的原因")])]),_._v(" "),s("p",[_._v("8086/8088 寄存器的大小是 16 位（范围是 64 KB），物理地址的大小是 20 位（范围是 1 MB）。这就造成一个矛盾，单独使用一个 16 位数不能表示或确定某一内存单元的物理地址。")]),_._v(" "),s("p",[s("strong",[_._v("解决办法")])]),_._v(" "),s("p",[_._v("Intel 引入段的概念：")]),_._v(" "),s("ul",[s("li",[_._v("段的大小可以变化")]),_._v(" "),s("li",[_._v("16 位 CPU 中最大的段为 2^16 = 64 KB，最小的段没有限制，因此可以定义 1B 的段")]),_._v(" "),s("li",[_._v("段的起始地址（简称段基址、段首址）可以在任何 16 的倍数上，这种段起始边界通常称为节或小段")]),_._v(" "),s("li",[_._v("段寄存器中存放 20 位段基址的高 16 位")])]),_._v(" "),s("p",[_._v("引入分段管理后，一个内存单元地址要用段基地址和偏移量两个逻辑地址来描述，表示为“段基址：偏移量”。")]),_._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),s("p",[_._v("因此，程序中给出的内存单元地址只是逻辑地址，而不是物理地址，真正的物理地址要通过 CPU 部件自动计算得到。")])]),_._v(" "),s("p",[_._v("存储器采用分段管理后，其物理地址的计算方法为："),s("code",[_._v("10H × 段基址 + 偏移量")]),_._v("（其中 H 表示是十六进制数）")]),_._v(" "),s("h3",{attrs:{id:"保护模式下分段管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#保护模式下分段管理"}},[_._v("#")]),_._v(" 保护模式下分段管理")]),_._v(" "),s("p",[_._v("保护模式下，逻辑地址同样由 “段基址：偏移量”的格式给出。"),s("strong",[_._v("不过用来存储段基址的段寄存器不再表示段的起始位置，而是用来表示"),s("code",[_._v("段选择符")]),_._v("，偏移量在保护模式下也是由 32 为的寄存器或存储器寻址方式给出的。")])]),_._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),s("p",[_._v("保护模式下，该地址表示形式称为虚拟地址，对应的地址空间称为虚拟地址空间。")])]),_._v(" "),s("p",[_._v("至于详细如何计算，可以看书 45 页的例子。")]),_._v(" "),s("p",[s("strong",[_._v("1. 段描述符")])]),_._v(" "),s("p",[_._v("段描述符位于 GDT 或 LDT 中，占 8 字节，包括段基址（32 位），限长（20 位）和属性（4 位）。")]),_._v(" "),s("p",[_._v("属性位中有一个 G（Granularity），叫做粒度。G = 1 时，限长以页位单位；G = 0 时，限长以字节为单位。")]),_._v(" "),s("p",[_._v("限长位在描述符中一共占 20 位。G = 1 时，线程的内容加上 1 就是段所占的页数，1 页的大小为 2 ^12 = 4 KB；G = 0 时，段限长以字节为单位，限长的内容 + 1 就是段所占的字节数。")]),_._v(" "),s("p",[s("strong",[_._v("2. 段的属性")])]),_._v(" "),s("p",[_._v("段的属性是由段选择符来决定的，对于同样一个线性地址范围，不同的选择符有不同的属性。")]),_._v(" "),s("p",[s("strong",[_._v("3. 段描述符高速缓存")])]),_._v(" "),s("p",[_._v("内存读写时，CPU 要计算线性地址，需要取得段描述符中的基地址再加上偏移量。接下来还需要根据段描述符的属性来操作。这样很耗时。")]),_._v(" "),s("p",[_._v("于是 CPU 在内部设置了段描述符高速缓存。")]),_._v(" "),s("p",[_._v("段描述符高速缓存总是与 CS、DS、ES、SS、FS、GS 段寄存器和描述符当前值保持一致，只有段寄存器的值发生改变时，才需要到 GDT 或 LDT 中装入段描述符。")]),_._v(" "),s("p",[s("strong",[_._v("4. 段式地址转换")])]),_._v(" "),s("p",[_._v("CPU 的分段部件完成将虚拟地址转换为线性地址。")]),_._v(" "),s("p",[_._v("CPU 的分页部件将线性地址转换为物理地址。如果禁止 CPU 的分页功能，线性地址就直接作为物理地址。")]),_._v(" "),s("h3",{attrs:{id:"页式内存管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#页式内存管理"}},[_._v("#")]),_._v(" 页式内存管理")]),_._v(" "),s("p",[s("img",{attrs:{src:t(446),alt:""}})]),_._v(" "),s("p",[_._v("分页管理是在分段管理机制的基础上工作的。")]),_._v(" "),s("p",[_._v("使用分页机制的好处在于它可以把每个活动任务当前所必须的少量页面放在内存中，而不必将整个段调入内存。")]),_._v(" "),s("p",[s("strong",[_._v("1. 分页")])]),_._v(" "),s("p",[_._v("由于线性地址是 32 位，所以线性地址空间为 2^32 = 4GB。")]),_._v(" "),s("table",[s("thead",[s("tr",[s("th",[_._v("管理模式")]),_._v(" "),s("th",[_._v("特点")])])]),_._v(" "),s("tbody",[s("tr",[s("td",[_._v("分段")]),_._v(" "),s("td",[_._v("段的长度不固定，段与段之间允许重叠")])]),_._v(" "),s("tr",[s("td",[_._v("分页")]),_._v(" "),s("td",[_._v("页的长度固定，页与页之间没有重叠")])])])]),_._v(" "),s("p",[s("strong",[_._v("2. 线性地址到物理地址的映射过程")])]),_._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),s("p",[_._v("每一个线性页面只能映射到一个物理页面上，但是多个线性页面可以映射到同一个物理页面上。")])]),_._v(" "),s("p",[_._v("分页机制就是一种将线性地址的页面映射到物理地址页面的手段，它用到了两个表，页目录表和页表。")]),_._v(" "),s("p",[s("img",{attrs:{src:t(447),alt:""}})]),_._v(" "),s("p",[s("img",{attrs:{src:t(448),alt:""}})]),_._v(" "),s("p",[s("strong",[_._v("3. 片内转换检测缓冲器")])]),_._v(" "),s("p",[_._v("页式内存管理中，每次内存操作都需要将线性地址转换为物理地址，每次都需要两次访问主存，分别访问页目录表和页表来取得页表描述符和页描述符，时间开销大。")]),_._v(" "),s("p",[_._v("于是 CPU 内置了片内转换检测缓冲器 TLB（Translation Look-aside Buffer），其中保存了 32 个页描述符，它们都是最近使用过的。")]),_._v(" "),s("p",[s("strong",[_._v("4. 页表项")])]),_._v(" "),s("p",[_._v("页表项就是在分页转换时用到的页表描述符和页描述符，它们都是 32 位的，其格式相同。")]),_._v(" "),s("p",[s("img",{attrs:{src:t(449),alt:""}})]),_._v(" "),s("ul",[s("li",[_._v("页目录表、页表和页面的"),s("strong",[_._v("基地址")]),_._v("的低 12 位全部为 0")]),_._v(" "),s("li",[s("strong",[_._v("页表描述符")]),_._v("的高 20 位就是"),s("strong",[_._v("页表基地址")]),_._v("的高 20 位")]),_._v(" "),s("li",[s("strong",[_._v("页描述符")]),_._v("的高 20 位就是"),s("strong",[_._v("物理页面基地址的高 20 位")])])]),_._v(" "),s("p",[_._v("页表项的低 12 位提供保护功能和统计功能，具体可以看书 54 页。")]),_._v(" "),s("p",[s("strong",[_._v("5. 线性地址转换为物理地址实例")])]),_._v(" "),s("p",[_._v("具体看书 55 页，例 2.7")])])}),[],!1,null,null,null);v.default=a.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[112],{585:function(n,t,v){"use strict";v.r(t);var _=v(25),r=Object(_.a)({},(function(){var n=this,t=n.$createElement,v=n._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[v("h1",{attrs:{id:"归并排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#归并排序"}},[n._v("#")]),n._v(" 归并排序")]),n._v(" "),v("p",[n._v("分治模式在每层递归都有三个模式：")]),n._v(" "),v("ul",[v("li",[v("strong",[n._v("分解")]),n._v("原问题为若干子问题， 这些子问题是原问题规模较小的实例")]),n._v(" "),v("li",[v("strong",[n._v("解决")]),n._v("这些子问题， 递归地求解各子问题。 然而， 若子问题规模足够小， 则直接求解")]),n._v(" "),v("li",[v("strong",[n._v("合并")]),n._v("这些子问题构成原问题的解")])]),n._v(" "),v("p",[n._v("归并排序的操作完全遵循分治模式：")]),n._v(" "),v("ul",[v("li",[v("strong",[n._v("分解")]),n._v("： 分解待排序的 n 个元素的序列成各具 n/2 个元素的子序列")]),n._v(" "),v("li",[v("strong",[n._v("解决")]),n._v("： 使用归并排序递归地排序两个子序列")]),n._v(" "),v("li",[v("strong",[n._v("合并")]),n._v("： 合并两个子序列已产生已排序的答案")])]),n._v(" "),v("p",[n._v("以整理两堆"),v("strong",[n._v("已排序")]),n._v("好的的扑克牌为例子， 归并排序的"),v("strong",[n._v("解决和合并部分")]),n._v("有以下注意点：")]),n._v(" "),v("ul",[v("li",[n._v("排序的两堆牌有副本， 即 "),v("code",[n._v("L[...]")]),n._v(" 和 "),v("code",[n._v("R[...]")]),n._v("， 它们相比两堆牌多了"),v("strong",[n._v("哨兵")]),n._v("（一张足够大的牌）")]),n._v(" "),v("li",[n._v("这两堆牌是已经排好序号的， 所有只需要拿出两堆牌顶端的牌进行比较就可以了， 即 "),v("code",[n._v("for k = p to r")]),n._v(" 之后的部分")])]),n._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[n._v("MERGE(A, p, q, r)\nn1 = q - p + 1\nn2 = r - q;\nlet L[1 ... n1 + 1] and R[1 ... n2 + 1] be new arrays\nfor i = 1 to n1\n  L[i] = A[p + i - 1]\nfor j = 1 to n2\n  R[j] = A[q + j]\nL[n1 + 1] = ∞\nR[n2 + 1] = ∞\ni = 1\nj = 1\nfor k = p to r\n  if L[i] < R[j]\n    A[k] = L[i]\n    i = i + 1\n  else\n    A[k] = R[j]\n    j = j + 1\n")])])]),v("p",[n._v("归并的分解部分有一个注意点：")]),n._v(" "),v("ul",[v("li",[n._v("分治函数是要递归调用自身的， 然后还要合并的")])]),n._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[n._v("MERGE-SORT(A, p, r)\nif p < r\n  q = ⌊(p + r) / 2⌋\n  MERGE-SORT[A, p, q]\n  MERGE-SORT[A, q + 1, r]\n  MERGE[A, p, q, r]\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);
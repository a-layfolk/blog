(window.webpackJsonp=window.webpackJsonp||[]).push([[121],{593:function(v,_,t){"use strict";t.r(_);var a=t(25),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"软件测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软件测试"}},[v._v("#")]),v._v(" 软件测试")]),v._v(" "),t("p",[v._v("软件测试是软件开发的最后一个流程。")]),v._v(" "),t("h2",{attrs:{id:"软件测试基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软件测试基础"}},[v._v("#")]),v._v(" 软件测试基础")]),v._v(" "),t("p",[t("code",[v._v("软件测试")]),v._v("是在一定软件环境下，以最小的成本来验证系统能否按照需求正确运行，并尽可能发现存在的错误。"),t("strong",[v._v("测试只能证明程序有错，而不能保证程序无措。")])]),v._v(" "),t("h2",{attrs:{id:"软件测试过程模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软件测试过程模型"}},[v._v("#")]),v._v(" 软件测试过程模型")]),v._v(" "),t("p",[t("code",[v._v("软件测试过程")]),v._v("主要包括：")]),v._v(" "),t("ul",[t("li",[v._v("测试对象。通常为代码，现代软件工程中也包括文档。")]),v._v(" "),t("li",[v._v("如何测试。要求有测试配置，测试环境配置，执行测试过程还有测试结果与预期结果比对。")])]),v._v(" "),t("p",[v._v("为了协调软件开发和软件测试，需要考虑软件测试过程模型。")]),v._v(" "),t("p",[t("strong",[v._v("测试的 V 模型")]),v._v("：")]),v._v(" "),t("p",[v._v("V 模型的重要价值在于，"),t("strong",[v._v("它定义了软件测试如何与软件工程各阶段相融合")]),v._v("。")]),v._v(" "),t("p",[v._v("V 模型中，软件开发和软件测试是并行的。")]),v._v(" "),t("p",[t("strong",[v._v("测试的 W 模型：")])]),v._v(" "),t("p",[v._v("W 模型是 V 模型的改进。"),t("strong",[v._v("它明确了软件开发各阶段都需要测试，而不仅仅是在编码结束后才开始。而且，测试对象不仅是代码，还可以是文档。")])]),v._v(" "),t("p",[t("strong",[v._v("测试的 H 模型：")])]),v._v(" "),t("p",[v._v("H 模型是对 W 模型在更高层次上的线性抽象。"),t("strong",[v._v("它明确了，在任何一个开发阶段，只要有必要且测试配置已准备就绪，就可以进行测试。")])]),v._v(" "),t("p",[v._v("W 模型和 H 模型对 V 模型的演化，目的都是强调软件测试的"),t("strong",[v._v("尽早性")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"软件测试原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软件测试原则"}},[v._v("#")]),v._v(" 软件测试原则")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),t("p",[v._v("个人觉得这部分原则比较大和空， 没记。")])]),v._v(" "),t("h2",{attrs:{id:"软件测试分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软件测试分类"}},[v._v("#")]),v._v(" 软件测试分类")]),v._v(" "),t("p",[v._v("软件测试分为"),t("code",[v._v("静态测试")]),v._v("和"),t("code",[v._v("动态测试")]),v._v("两类。")]),v._v(" "),t("p",[v._v("就源程序而言，静态测试不需要运行就可以找出错误，动态测试则需要运行才能找出错误。")]),v._v(" "),t("ul",[t("li",[v._v("静态测试\n"),t("ul",[t("li",[v._v("桌面检查")]),v._v(" "),t("li",[v._v("代码检查，参照文档检查代码，目的是检查错误而不是如何修改。")]),v._v(" "),t("li",[v._v("代码走查，将测试用例输入电脑，人工查看，一般是确定程序逻辑是否正确。")])])]),v._v(" "),t("li",[v._v("动态测试\n"),t("ul",[t("li",[t("strong",[v._v("白盒测试")]),v._v("。针对程序内部逻辑结构进行测试。关心程序内部的细节，")]),v._v(" "),t("li",[v._v("**黑盒测试。**将模块作为一个整体进行测试，只关注模块的输入输出。")])])])]),v._v(" "),t("h3",{attrs:{id:"白盒测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#白盒测试"}},[v._v("#")]),v._v(" 白盒测试")]),v._v(" "),t("p",[v._v("白盒测试是基于文档的测试。它的测试用例设计是关键。其设计原则是：保证所有判断分支、循环体、边界值和独立路径都至少执行一次。")]),v._v(" "),t("p",[v._v("白盒测试技术又分为：逻辑覆盖、循环测试和路径测试。")]),v._v(" "),t("h4",{attrs:{id:"逻辑覆盖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#逻辑覆盖"}},[v._v("#")]),v._v(" 逻辑覆盖")]),v._v(" "),t("ul",[t("li",[v._v("语句覆盖，程序中每条语句至少执行一次")]),v._v(" "),t("li",[v._v("判定覆盖，所有判定的分支至少执行一次")]),v._v(" "),t("li",[v._v("条件覆盖，判定中的关系式的值，取 真/假 至少一次")]),v._v(" "),t("li",[v._v("判定/条件覆盖，所有判定分支至少执行一次，判定中关系式的值也取 真/假 至少一次")]),v._v(" "),t("li",[v._v("条件组合覆盖，比如有判定式的关系式为 C1 && C2，C3 && C4，则要把它们的 C1C2 的 4 种真假组合，C3C4 的 4 种真假组合全部执行")]),v._v(" "),t("li",[v._v("点覆盖，在逻辑覆盖中指的就是语句覆盖")]),v._v(" "),t("li",[v._v("边覆盖，在逻辑覆盖中指的就是判定覆盖")])]),v._v(" "),t("h4",{attrs:{id:"循环测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#循环测试"}},[v._v("#")]),v._v(" 循环测试")]),v._v(" "),t("p",[v._v("结构化的程序设计中有三种循环：简单循环、顺序循环和嵌套循环。对这三种循环有不同的测试策略，可以看书 151 页。")]),v._v(" "),t("h4",{attrs:{id:"路径测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#路径测试"}},[v._v("#")]),v._v(" 路径测试")]),v._v(" "),t("p",[v._v("路径测试分为三步:")]),v._v(" "),t("ul",[t("li",[v._v("计算程序流图的环形复杂度。")]),v._v(" "),t("li",[v._v("确定需要执行进行测试的程序独立路径。")]),v._v(" "),t("li",[v._v("根据测试路径设计测试用例。")])]),v._v(" "),t("h5",{attrs:{id:"环形复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#环形复杂度"}},[v._v("#")]),v._v(" 环形复杂度")]),v._v(" "),t("p",[v._v("首先要把程序转换为程序流图。")]),v._v(" "),t("p",[v._v("环形复杂度 V(G) 有三种计算方法：")]),v._v(" "),t("ul",[t("li",[v._v("V(G) = E - N + 2，即 边的数量 - 点的数量 + 2")]),v._v(" "),t("li",[v._v("V(G) = P + 1，即判定节点的数量 + 1")]),v._v(" "),t("li",[v._v("V(G) = 流图中封闭区域的个数。可以人为添加一条从结束节点到开始节点的“虚”控制流")])]),v._v(" "),t("h5",{attrs:{id:"程序独立路径"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#程序独立路径"}},[v._v("#")]),v._v(" 程序独立路径")]),v._v(" "),t("p",[v._v("流图的环形复杂度定义了程序独立路径的数量。")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),t("p",[v._v("程序独立路径是指从程序入口到出口多次执行中，每次至少有一个语句是新的。即每次都要走过一条从未经过的边。")])]),v._v(" "),t("h3",{attrs:{id:"黑盒测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#黑盒测试"}},[v._v("#")]),v._v(" 黑盒测试")]),v._v(" "),t("p",[v._v("完成黑盒测试的成员组成最好不要涉及程序员。")]),v._v(" "),t("p",[v._v("以下是几类黑盒测试技术：")]),v._v(" "),t("ul",[t("li",[v._v("等价类划分。有两种情形，有效等价类和无效等价类。\n"),t("ul",[t("li",[v._v("有效等价类是指对程序而言，有意义且合理的数据。")]),v._v(" "),t("li",[v._v("无效等价类是指对程序而言，无意义的数据。")])])]),v._v(" "),t("li",[v._v("边界值分析。")]),v._v(" "),t("li",[v._v("错误推测法。不同于其他方法，错误推测法无规律可循，全凭经验和直觉。")]),v._v(" "),t("li",[v._v("因果图法。列出因果，画出因果图，将因果图转换为判定表，再给出判定表中的每组的测试用例。")])]),v._v(" "),t("div",{staticClass:"custom-block danger"},[t("p",{staticClass:"custom-block-title"},[v._v("WARNING")]),v._v(" "),t("p",[v._v("白盒测试又称结构测试、逻辑驱动测试或基于程序的测试。")]),v._v(" "),t("p",[v._v("黑盒测试又称为功能测试或行为测试。")]),v._v(" "),t("p",[v._v("原本这种别称我是不想记的，但是 2018 年的软工考试试卷上出现了使用别称作为迷惑的选择题。")])]),v._v(" "),t("h4",{attrs:{id:"白盒测试和黑盒测试比较"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#白盒测试和黑盒测试比较"}},[v._v("#")]),v._v(" 白盒测试和黑盒测试比较")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th"),v._v(" "),t("th",[v._v("技术")]),v._v(" "),t("th",[v._v("人员")]),v._v(" "),t("th",[v._v("文档")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("白盒")]),v._v(" "),t("td",[v._v("关心局部")]),v._v(" "),t("td",[v._v("程序员和测试人员")]),v._v(" "),t("td",[v._v("需要详细的设计文档")])]),v._v(" "),t("tr",[t("td",[v._v("黑盒")]),v._v(" "),t("td",[v._v("关心整体")]),v._v(" "),t("td",[v._v("较多的人，比如用户和非技术人员")]),v._v(" "),t("td",[v._v("需要需求规格说明和概要设计说明")])])])]),v._v(" "),t("table",[t("thead",[t("tr",[t("th"),v._v(" "),t("th",[v._v("优点")]),v._v(" "),t("th",[v._v("缺点")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("白盒")]),v._v(" "),t("td",[v._v("发现大量错误，有较多工具，部分用例能自动生成")]),v._v(" "),t("td",[v._v("相当数据要人工生成，理解代码工作量大。仅适用单元测试")])]),v._v(" "),t("tr",[t("td",[v._v("黑盒")]),v._v(" "),t("td",[v._v("不需要了解细节，容易生成用例，使用任何阶段")]),v._v(" "),t("td",[v._v("容易重复、遗漏某些错误")])])])]),v._v(" "),t("h2",{attrs:{id:"软件测试策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软件测试策略"}},[v._v("#")]),v._v(" 软件测试策略")]),v._v(" "),t("p",[v._v("软件测试从局部到全局，包括：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("单元测试")])]),v._v(" "),t("li",[t("p",[v._v("集成测试")])]),v._v(" "),t("li",[t("p",[v._v("确认测试")])]),v._v(" "),t("li",[t("p",[v._v("系统测试")]),v._v(" "),t("p",[v._v("系统测试是几乎涵盖了前述测试的所有内容，主要包括：")]),v._v(" "),t("ul",[t("li",[v._v("功能测试")]),v._v(" "),t("li",[v._v("性能测试")]),v._v(" "),t("li",[v._v("压力测试")]),v._v(" "),t("li",[v._v("容量测试")]),v._v(" "),t("li",[v._v("安全测试")]),v._v(" "),t("li",[v._v("文档测试")]),v._v(" "),t("li",[v._v("恢复性测试")]),v._v(" "),t("li",[v._v("备份测试")])]),v._v(" "),t("p",[v._v("这里还有一个 α 测试和 β 测试的概念：α 测试是指开发环境下，用户和软件开发人员、测试人员共同对系统进行的测试。β 测试是在系统实际用户使用环境下的进行的测试，整个过程由用户独立完成。")])])]),v._v(" "),t("h2",{attrs:{id:"调试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#调试"}},[v._v("#")]),v._v(" 调试")]),v._v(" "),t("ul",[t("li",[v._v("试探法")]),v._v(" "),t("li",[v._v("归纳法")]),v._v(" "),t("li",[v._v("演绎法")]),v._v(" "),t("li",[v._v("回溯法")])]),v._v(" "),t("h2",{attrs:{id:"软件测试报告"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软件测试报告"}},[v._v("#")]),v._v(" 软件测试报告")]),v._v(" "),t("p",[v._v("包括：")]),v._v(" "),t("ul",[t("li",[v._v("软件测试说明（Software Testing Description，STD）")]),v._v(" "),t("li",[v._v("软件测试报告（Software Testing Report, STR）")])])])}),[],!1,null,null,null);_.default=s.exports}}]);
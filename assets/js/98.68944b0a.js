(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{565:function(t,s,a){"use strict";a.r(s);var e=a(25),v=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"汇编语言与接口技术"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#汇编语言与接口技术"}},[t._v("#")]),t._v(" 汇编语言与接口技术")]),t._v(" "),a("p",[t._v("一条指令通常由操作码域和操作数域两部分组成，操作码域指示计算机要执行的操作，操作数域则提供与操作数或操作数地址有关的信息。")]),t._v(" "),a("h2",{attrs:{id:"数据寻址方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据寻址方式"}},[t._v("#")]),t._v(" 数据寻址方式")]),t._v(" "),a("p",[t._v("以 MOV 为例子，MOV 指令的汇编格式为")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("MOV 目标, 源\t\t\t;把源操作数传送给目标\n")])])]),a("ul",[a("li",[t._v("目标和源是操作数，中间用逗号隔开")]),t._v(" "),a("li",[t._v('注释内容从 ";" 开始')])]),t._v(" "),a("h3",{attrs:{id:"cpu-操作数寻址"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cpu-操作数寻址"}},[t._v("#")]),t._v(" CPU 操作数寻址")]),t._v(" "),a("p",[a("strong",[t._v("1. 立即寻址方式")])]),t._v(" "),a("p",[t._v("操作数直接包含再指令中，紧跟在操作数之后的寻址方式称为立即寻址方式，把该操作数简称为立即数。例如：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("MOV BL, 9\t\t\t;执行结果（BL）= 9\n")])])]),a("ul",[a("li",[t._v("立即数不能作为目标操作数")]),t._v(" "),a("li",[t._v("源操作数和目标操作数位数要一致")])]),t._v(" "),a("p",[a("strong",[t._v("2. 寄存器寻址方式")])]),t._v(" "),a("p",[t._v("操作数直接包含在寄存器中，由指令指定寄存器的寻址方式。例如：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("MOV BX, AX\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("一般通用寄存器可以出现在寄存器寻址方式中。")]),t._v(" "),a("p",[t._v("而一般 "),a("code",[t._v("MOV EIP OFH")]),t._v(" 类指令不合法，因为 EIP 比较特殊。")])]),t._v(" "),a("h2",{attrs:{id:"存储器操作数寻址"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存储器操作数寻址"}},[t._v("#")]),t._v(" 存储器操作数寻址")]),t._v(" "),a("p",[t._v("参与运算的操作数来自存储器（RAM）")]),t._v(" "),a("p",[a("strong",[t._v("1. 直接寻址方式")])]),t._v(" "),a("p",[t._v("操作数的有效地址 Effective Address（EA）直接包含在指令中。")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("EA 只是操作数地址的偏移量部分。其物理地址还需要把有效地址和段基址相加得到。")]),t._v(" "),a("ul",[a("li",[t._v("80x86 实模式下，段基址 = 段寄存器内容 x 16")]),t._v(" "),a("li",[t._v("保护模式，段寄存器的描述符索引 ---从描述符表中得到描述符--\x3e 从描述符中得到段基址")])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("MOV EAX,[00404011H]\t\t\t;把 00404011H 单元中的内容送给 EAX\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("MOV EAX,VAR\t\t\t\t\t;VAR 是一个内存变量名，代表一个内存单元的符号地址\n\t\t\t\t;实际上，在汇编语言源程序中所看到的直接寻址方式通常都是用符号表示的\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("MOV EBX,ES:MEM\t\t\t\t;该指定源操作数的有效地址时用变量名表示的 MEM\n")])])]),a("p",[a("strong",[t._v("2. 寄存器间接寻址方式")])]),t._v(" "),a("ul",[a("li",[t._v("操作数的有效地址在寄存器")]),t._v(" "),a("li",[t._v("操作数本身在存储器")]),t._v(" "),a("li",[t._v("对于 16 位寻址，这个寄存器只能是基址寄存器 BX、BP 或变量寄存器 SI、DI")]),t._v(" "),a("li",[t._v("对于 32 位寻址，允许使用任何 32 位通用寄存器")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("MOV AL,[BX]\t\t\t;BX 用 [] 括起来，它表示 BX 寄存器中是有效地址而不是操作数\n")])])]),a("p",[a("strong",[t._v("3. 寄存器相对寻址方式")])]),t._v(" "),a("p",[a("strong",[t._v("4. 基址变址寻址方式")])]),t._v(" "),a("p",[a("strong",[t._v("5. 相对基址变址寻址方式")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash\nhttps://gitee.com/mirrors/nvm.git\ngit clone https://gitee.com/mirrors/nvm\n")])])])])}),[],!1,null,null,null);s.default=v.exports}}]);
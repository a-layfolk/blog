(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{594:function(v,_,t){"use strict";t.r(_);var s=t(25),a=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"结构化设计方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结构化设计方法"}},[v._v("#")]),v._v(" 结构化设计方法")]),v._v(" "),t("p",[t("code",[v._v("结构化设计")]),v._v(" （Structure Design, SD）的基础是模块。")]),v._v(" "),t("p",[v._v("结构化设计的基本思想是：基于模块独立性和信息隐藏原则， 自顶向下， 逐步求精， 分解与抽象相结合， 并应用结构化程序设计技术而进行的软件设计。")]),v._v(" "),t("p",[v._v("结构化设计一般分为两个阶段：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("第一阶段完成对软件结构设计， 从而得到系统软件结构图；")])]),v._v(" "),t("li",[t("p",[v._v("第二阶段得到软件系统的详细设计")])])]),v._v(" "),t("h2",{attrs:{id:"面向数据流的设计方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向数据流的设计方法"}},[v._v("#")]),v._v(" 面向数据流的设计方法")]),v._v(" "),t("p",[v._v("结构化设计"),t("strong",[v._v("以数据流图为基础")]),v._v("， 根据对数据流图理解的不同， 以及对数据流图自动边界划分的不同， 分为"),t("code",[v._v("变换分析法")]),v._v("、"),t("code",[v._v("事务分析法")]),v._v("和"),t("code",[v._v("混合分析法")]),v._v("。")]),v._v(" "),t("h3",{attrs:{id:"变换分析法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#变换分析法"}},[v._v("#")]),v._v(" 变换分析法")]),v._v(" "),t("p",[v._v("变换分析法是一个迭代的分析过程。   具体内容看课本 101 页。")]),v._v(" "),t("p",[v._v("变换分析法分为六个步骤：")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("复审并精细化数据流图")])]),v._v(" "),t("li",[t("p",[v._v("划分自动化边界， 确定数据流特征， 判断数据流是变换流还是事务流。")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),t("p",[v._v("变换流的特征是数据有明显输入、 处理和输出过程， 在处理部分没有过多的控制和判断")])])]),v._v(" "),t("li",[t("p",[v._v("划分数据输入输出边界， 分离出处理部分")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),t("p",[v._v("输入、 输出边界不同于自动化边界， 自动化边界的划分体现的是分析员对软件系统结构的处理方式。 而数据、 输出边界划分与软件结构的处理无关， 仅表示系统与外部数据的交流。 数据输入和输出边界通常是自动化边界的子图（子集）。")])])]),v._v(" "),t("li",[t("p",[v._v("执行一级分解")]),v._v(" "),t("p",[v._v("所谓一级分解， 是指导出软件逻辑结构的最上两层关系， 顶层为"),t("code",[v._v("系统主控模块")]),v._v("（MC）、第二层根据自动边界划分， 分为"),t("code",[v._v("输入模块")]),v._v("（MI）、"),t("code",[v._v("输出模块")]),v._v("（MO）和"),t("code",[v._v("控制模块")]),v._v("（MT）。")])]),v._v(" "),t("li",[t("p",[v._v("执行二级分解")])]),v._v(" "),t("li",[t("p",[v._v("采用启发式规则， 精细化所得到的初步软件结构。")])])]),v._v(" "),t("hr"),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),t("p",[v._v("在实际绘图中， 为了明确说明各模块间的调用关系， 形成接口设计说明书的部分内容， 有必要为每隔模块编写一个简要说明。")])]),v._v(" "),t("p",[v._v("通过上述六个步骤得到软件结构图。 这样设计人员可以从整体上把握软件结构， 定义模块间接口， 并为单元测试、 集成测试提供依据。")]),v._v(" "),t("h3",{attrs:{id:"事务分析法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事务分析法"}},[v._v("#")]),v._v(" 事务分析法")]),v._v(" "),t("p",[v._v("事务分析法与变换分析法设计过程基本相同。")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("复审并精华数据流图")])]),v._v(" "),t("li",[t("p",[v._v("确定数据流图特征， 判断是事务流还是变换流。")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),t("p",[v._v("事务流的特征是在数据的输入、处理和输出过程中， 处理部分有明显的控制或判断中心， 后续的数据流中有较多活动路径。")])])]),v._v(" "),t("li",[t("p",[v._v("设定自动化边界， 分理出事务中心和事务路径。")])]),v._v(" "),t("li",[t("p",[v._v("执行一级分解")]),v._v(" "),t("p",[v._v("事务分析法整体结构是两层结构。 顶层是系统主控模块， 第二层是输入模块和事务调度模块。")])]),v._v(" "),t("li",[t("p",[v._v("执行二级分解")])]),v._v(" "),t("li",[t("p",[v._v("采用启发式规则， 精化所得到的初步软件结构。")])])]),v._v(" "),t("h3",{attrs:{id:"混合分析法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#混合分析法"}},[v._v("#")]),v._v(" 混合分析法")]),v._v(" "),t("p",[v._v("在大规模和复杂系统的数据流图中， 常常需要将变换分析法和事务分析法结合使用， 共同构建软件系统结构图。")]),v._v(" "),t("p",[v._v("混合分析法和变换分析法过程相同， 只是第二步骤时， 需确定数据流图中变换的自动化边界或确定事务中心。")]),v._v(" "),t("h2",{attrs:{id:"结构化详细设计的工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结构化详细设计的工具"}},[v._v("#")]),v._v(" 结构化详细设计的工具")]),v._v(" "),t("p",[v._v("结构化设计的详细设计阶段，主要完成系统各模块功能的过程描述。 详细设计提供了图形、表格和语言等三类不同工具。")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("工具")]),v._v(" "),t("th",[v._v("说明")]),v._v(" "),t("th",[v._v("优点")]),v._v(" "),t("th",[v._v("缺点")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("程序流程图")]),v._v(" "),t("td"),v._v(" "),t("td",[v._v("易懂、易学、易画")]),v._v(" "),t("td",[v._v("1. 控制流（有向箭头）无法约束其转向，造成设计的随意性，并可能导致非结构化的过程设计。"),t("br"),v._v("2. 难以表达数据结构， 比如数组就难以表达")])]),v._v(" "),t("tr",[t("td",[v._v("盒图")]),v._v(" "),t("td",[v._v("NS 图")]),v._v(" "),t("td",[v._v("1. 控制域明晰，能直接分析出分支、循环的控制域范围。"),t("br"),v._v("2. 无控制流，避免了控制流程的随意性。"),t("br"),v._v("3. 方块嵌套有层级性")]),v._v(" "),t("td")]),v._v(" "),t("tr",[t("td",[v._v("问题分析图")]),v._v(" "),t("td",[v._v("PAD 图")]),v._v(" "),t("td",[v._v("1. 层次清晰，作用域明显"),t("br"),v._v("2. 自顶向下， 自左向右易于理解"),t("br"),v._v("3. 无控制流<br//>4. 可以表达复杂数据结构")]),v._v(" "),t("td")]),v._v(" "),t("tr",[t("td",[v._v("判定树")]),v._v(" "),t("td",[v._v("多叉树，每棵子树就是当前树节点判断的分支路径")]),v._v(" "),t("td"),v._v(" "),t("td",[v._v("1. 对复合条件的选择中， 难以确定以何种顺序作为符合条件的判断顺序"),t("br"),v._v("2. 难以表达结构化设计的控制结构"),t("br"),v._v("3. 难以将判断树直接转换为程序设计语言")])]),v._v(" "),t("tr",[t("td",[v._v("过程描述语言")]),v._v(" "),t("td",[v._v("PDL或者PL(伪码语言)")]),v._v(" "),t("td"),v._v(" "),t("td")])])])])}),[],!1,null,null,null);_.default=a.exports}}]);